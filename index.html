<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>In-silico-synth</title>
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        width: 100vw;
        font-family: monospace;
        overflow: hidden;
        position: relative;
        background-color: #17171b;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url("assets/noisy_bckg.png");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        filter: blur(2px);
        z-index: -1;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      body.loaded::before {
        opacity: 1;
      }

      #main-content {
        position: relative;
        z-index: 10;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      body.loaded #main-content {
        opacity: 1;
      }

      .pixelated-circle {
        width: 800px;
        height: 800px;
        border-radius: 50%;
        position: relative;
        margin: 0 auto;
        flex-shrink: 0;
        pointer-events: none;
        background: radial-gradient(
          circle at 30% 30%,
          rgba(255, 255, 255, 0.4) 0%,
          rgba(255, 255, 255, 0.1) 30%,
          rgba(173, 216, 230, 0.2) 50%,
          rgba(135, 206, 250, 0.15) 70%,
          rgba(70, 130, 180, 0.1) 100%
        );
        border: 2px solid rgba(255, 255, 255, 0.3);
        box-shadow: 0 0 40px rgba(135, 206, 250, 0.3),
          inset 0 0 60px rgba(255, 255, 255, 0.1),
          inset -50px -50px 100px rgba(70, 130, 180, 0.2);
        overflow: hidden;
      }

      /* Bubble highlight/shine effect */
      .pixelated-circle::before {
        content: "";
        position: absolute;
        top: 15%;
        left: 25%;
        width: 30%;
        height: 30%;
        border-radius: 50%;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.25) 0%,
          rgba(255, 255, 255, 0.15) 40%,
          transparent 70%
        );
        pointer-events: none;
        animation: shimmer 8s ease-in-out infinite;
      }

      /* Secondary highlight */
      .pixelated-circle::after {
        content: "";
        position: absolute;
        top: 10%;
        left: 20%;
        width: 15%;
        height: 15%;
        border-radius: 50%;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.3) 0%,
          transparent 60%
        );
        pointer-events: none;
        animation: shimmer 6s ease-in-out infinite 0.5s;
      }

      @keyframes shimmer {
        0%,
        100% {
          opacity: 0.3;
          transform: translate(0, 0) scale(1);
        }
        50% {
          opacity: 0.5;
          transform: translate(5px, 5px) scale(1.05);
        }
      }

      /* Container for dots inside the circle */
      #inner-dots {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        pointer-events: none;
      }

      /* Corner dot containers */
      .corner-container {
        position: fixed;
        width: 50px;
        height: 50px;
        z-index: 5;
      }

      .top-left {
        top: 20px;
        left: 20px;
      }

      .top-right {
        top: 20px;
        right: 20px;
      }

      .bottom-left {
        bottom: 20px;
        left: 20px;
      }

      .bottom-right {
        bottom: 20px;
        right: 20px;
      }

      .left-margin {
        top: 50%;
        left: 20px;
      }

      .right-margin {
        top: 50%;
        right: 20px;
      }

      /* Individual dots */
      .corner-dot {
        position: absolute;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        cursor: grab;
        user-select: none;
        z-index: 100;
        touch-action: none;
        pointer-events: auto;
        transition: opacity 0.3s ease;
      }

      .corner-dot:hover {
        box-shadow: 0 0 15px currentColor;
      }

      .corner-dot.dragging {
        cursor: grabbing;
        z-index: 1000;
        position: fixed !important;
        transform: scale(1.3);
        box-shadow: 0 0 25px currentColor;
      }

      /* Dots inside the circle */
      .inner-dot {
        position: absolute;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        cursor: grab;
        user-select: none;
        z-index: 100;
        touch-action: none;
        pointer-events: auto;
        margin-left: -12px;
        margin-top: -12px;
        transition: opacity 0.3s ease;
      }

      .inner-dot:hover {
        box-shadow: 0 0 15px currentColor;
      }

      .inner-dot.dragging {
        cursor: grabbing;
        z-index: 1000;
        position: fixed !important;
        transform: scale(1.3) !important;
        box-shadow: 0 0 25px currentColor;
      }

      /* Color variations for each corner */
      .top-left .corner-dot {
        background-color: #4a90e2;
      }

      .top-right .corner-dot {
        background-color: #f57023;
      }

      .bottom-left .corner-dot {
        background-color: #7ed321;
      }

      .bottom-right .corner-dot {
        background-color: #d0021b;
      }

      .left-margin .corner-dot {
        background-color: #9b59b6;
      }

      .right-margin .corner-dot {
        background-color: #ffae00;
      }

      /* Play button styles */
      #play-button {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 60px;
        height: 60px;
        border: none;
        background: transparent;
        color: white;
        font-size: 40px;
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        pointer-events: auto;
      }
    </style>
  </head>
  <body>
    <!-- Main content -->
    <div id="main-content">
      <div class="pixelated-circle">
        <div id="inner-dots"></div>
      </div>
    </div>

    <!-- Corner dots -->
    <div class="corner-container top-left">
      <div class="corner-dot" style="--i: 0"></div>
      <div class="corner-dot" style="--i: 1"></div>
      <div class="corner-dot" style="--i: 2"></div>
      <div class="corner-dot" style="--i: 3"></div>
      <div class="corner-dot" style="--i: 4"></div>
      <div class="corner-dot" style="--i: 5"></div>
      <div class="corner-dot" style="--i: 6"></div>
      <div class="corner-dot" style="--i: 7"></div>
    </div>

    <div class="corner-container top-right">
      <div class="corner-dot" style="--i: 0"></div>
      <div class="corner-dot" style="--i: 1"></div>
      <div class="corner-dot" style="--i: 2"></div>
      <div class="corner-dot" style="--i: 3"></div>
      <div class="corner-dot" style="--i: 4"></div>
      <div class="corner-dot" style="--i: 5"></div>
      <div class="corner-dot" style="--i: 6"></div>
      <div class="corner-dot" style="--i: 7"></div>
      <div class="corner-dot" style="--i: 8"></div>
      <div class="corner-dot" style="--i: 9"></div>
      <div class="corner-dot" style="--i: 10"></div>
      <div class="corner-dot" style="--i: 11"></div>
      <div class="corner-dot" style="--i: 12"></div>
      <div class="corner-dot" style="--i: 13"></div>
      <div class="corner-dot" style="--i: 14"></div>
      <div class="corner-dot" style="--i: 15"></div>
      <div class="corner-dot" style="--i: 16"></div>
      <div class="corner-dot" style="--i: 17"></div>
      <div class="corner-dot" style="--i: 18"></div>
      <div class="corner-dot" style="--i: 19"></div>
    </div>

    <div class="corner-container bottom-left">
      <div class="corner-dot" style="--i: 0"></div>
      <div class="corner-dot" style="--i: 1"></div>
      <div class="corner-dot" style="--i: 2"></div>
      <div class="corner-dot" style="--i: 3"></div>
      <div class="corner-dot" style="--i: 4"></div>
      <div class="corner-dot" style="--i: 5"></div>
      <div class="corner-dot" style="--i: 6"></div>
      <div class="corner-dot" style="--i: 7"></div>
      <div class="corner-dot" style="--i: 8"></div>
      <div class="corner-dot" style="--i: 9"></div>
      <div class="corner-dot" style="--i: 10"></div>
      <div class="corner-dot" style="--i: 11"></div>
      <div class="corner-dot" style="--i: 12"></div>
      <div class="corner-dot" style="--i: 13"></div>
      <div class="corner-dot" style="--i: 14"></div>
      <div class="corner-dot" style="--i: 15"></div>
      <div class="corner-dot" style="--i: 16"></div>
      <div class="corner-dot" style="--i: 17"></div>
      <div class="corner-dot" style="--i: 18"></div>
      <div class="corner-dot" style="--i: 19"></div>
    </div>

    <div class="corner-container bottom-right">
      <div class="corner-dot" style="--i: 0"></div>
      <div class="corner-dot" style="--i: 1"></div>
      <div class="corner-dot" style="--i: 2"></div>
      <div class="corner-dot" style="--i: 3"></div>
      <div class="corner-dot" style="--i: 4"></div>
      <div class="corner-dot" style="--i: 5"></div>
      <div class="corner-dot" style="--i: 6"></div>
      <div class="corner-dot" style="--i: 7"></div>
      <div class="corner-dot" style="--i: 8"></div>
      <div class="corner-dot" style="--i: 9"></div>
      <div class="corner-dot" style="--i: 10"></div>
      <div class="corner-dot" style="--i: 11"></div>
      <div class="corner-dot" style="--i: 12"></div>
      <div class="corner-dot" style="--i: 13"></div>
      <div class="corner-dot" style="--i: 14"></div>
      <div class="corner-dot" style="--i: 15"></div>
      <div class="corner-dot" style="--i: 16"></div>
      <div class="corner-dot" style="--i: 17"></div>
      <div class="corner-dot" style="--i: 18"></div>
      <div class="corner-dot" style="--i: 19"></div>
    </div>

    <div class="corner-container left-margin">
      <div class="corner-dot" style="--i: 0"></div>
      <div class="corner-dot" style="--i: 1"></div>
      <div class="corner-dot" style="--i: 2"></div>
      <div class="corner-dot" style="--i: 3"></div>
      <div class="corner-dot" style="--i: 4"></div>
      <div class="corner-dot" style="--i: 5"></div>
      <div class="corner-dot" style="--i: 6"></div>
      <div class="corner-dot" style="--i: 7"></div>
      <div class="corner-dot" style="--i: 8"></div>
      <div class="corner-dot" style="--i: 9"></div>
      <div class="corner-dot" style="--i: 10"></div>
      <div class="corner-dot" style="--i: 11"></div>
      <div class="corner-dot" style="--i: 12"></div>
      <div class="corner-dot" style="--i: 13"></div>
      <div class="corner-dot" style="--i: 14"></div>
      <div class="corner-dot" style="--i: 15"></div>
      <div class="corner-dot" style="--i: 16"></div>
      <div class="corner-dot" style="--i: 17"></div>
      <div class="corner-dot" style="--i: 18"></div>
      <div class="corner-dot" style="--i: 19"></div>
    </div>

    <div class="corner-container right-margin">
      <div class="corner-dot" style="--i: 0"></div>
      <div class="corner-dot" style="--i: 1"></div>
      <div class="corner-dot" style="--i: 2"></div>
      <div class="corner-dot" style="--i: 3"></div>
      <div class="corner-dot" style="--i: 4"></div>
      <div class="corner-dot" style="--i: 5"></div>
      <div class="corner-dot" style="--i: 6"></div>
      <div class="corner-dot" style="--i: 7"></div>
      <div class="corner-dot" style="--i: 8"></div>
      <div class="corner-dot" style="--i: 9"></div>
      <div class="corner-dot" style="--i: 10"></div>
      <div class="corner-dot" style="--i: 11"></div>
      <div class="corner-dot" style="--i: 12"></div>
      <div class="corner-dot" style="--i: 13"></div>
      <div class="corner-dot" style="--i: 14"></div>
      <div class="corner-dot" style="--i: 15"></div>
      <div class="corner-dot" style="--i: 16"></div>
      <div class="corner-dot" style="--i: 17"></div>
      <div class="corner-dot" style="--i: 18"></div>
      <div class="corner-dot" style="--i: 19"></div>
    </div>

    <!-- Play button -->
    <button id="play-button" aria-label="Play audio">▶</button>

    <script>
      // ================== helpers & globals ==================
      let activeDot = null;
      let startX = 0;
      let startY = 0;
      let dotStartX = 0;
      let dotStartY = 0;
      let innerDotCounter = 0;

      const circle = document.querySelector(".pixelated-circle");
      const innerDotsContainer = document.getElementById("inner-dots");

      const dotMovement = new WeakMap();

      const colors = [
        "#4a90e2",
        "#f5a623",
        "#7ed321",
        "#d0021b",
        "#9b59b6",
        "#e74c3c",
        "#1abc9c",
        "#f39c12",
      ];

      // Colors that form chains
      const CHAIN_FORMING_COLORS = ["#d0021b", "#4a90e2"]; // Red and Blue

      // Helper to normalize color strings for comparison
      function normalizeColorString(c) {
        if (!c) return "";
        return c.trim().toLowerCase();
      }

      // Convert color to canonical hex format for use as a key
      function getCanonicalColorKey(colorStr) {
        const normalized = normalizeColorString(colorStr);

        // If already hex, return it
        if (normalized.startsWith("#")) {
          return normalized;
        }

        // Parse rgb/rgba format: "rgb(208, 2, 27)" or "rgba(208, 2, 27, 1)"
        const rgbMatch = normalized.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (rgbMatch) {
          const r = parseInt(rgbMatch[1]).toString(16).padStart(2, "0");
          const g = parseInt(rgbMatch[2]).toString(16).padStart(2, "0");
          const b = parseInt(rgbMatch[3]).toString(16).padStart(2, "0");
          return `#${r}${g}${b}`;
        }

        return normalized;
      }

      // Check if a color string matches a chain-forming color
      function isChainFormingColorString(c) {
        const normalized = normalizeColorString(c);
        // Check all formats: hex, rgb, rgba
        return (
          normalized === "#d0021b" ||
          normalized === "rgb(208, 2, 27)" ||
          normalized === "rgba(208, 2, 27, 1)" ||
          normalized === "#4a90e2" ||
          normalized === "rgb(74, 144, 226)" ||
          normalized === "rgba(74, 144, 226, 1)"
        );
      }

      // Check if an element is a chain-forming dot
      function isChainFormingDot(el) {
        const c = window.getComputedStyle(el).backgroundColor;
        return isChainFormingColorString(c);
      }

      // Get the canonical color key from an element (for use as dictionary key)
      function getDotColor(el) {
        const colorStr = window.getComputedStyle(el).backgroundColor;
        return getCanonicalColorKey(colorStr);
      }

      // simple 2d vector helpers
      function v(x, y) {
        return { x, y };
      }
      function vAdd(a, b) {
        return { x: a.x + b.x, y: a.y + b.y };
      }
      function vSub(a, b) {
        return { x: a.x - b.x, y: a.y - b.y };
      }
      function vMul(a, s) {
        return { x: a.x * s, y: a.y * s };
      }
      function vLen(a) {
        return Math.hypot(a.x, a.y);
      }
      function vNorm(a) {
        const l = vLen(a);
        return l === 0 ? { x: 0, y: 0 } : { x: a.x / l, y: a.y / l };
      }
      function vLerp(a, b, t) {
        return { x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t };
      }
      function vRotate(a, theta) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        return { x: a.x * c - a.y * s, y: a.x * s + a.y * c };
      }

      // ================== chain config ==================
      const CHAIN_SPACING = 20; // distance between chain dots
      const CHAIN_MAX_RADIUS = 350;
      const CHAIN_ADD_INTERVAL = 5000;
      const CHAIN_MAX_LEN = 9;
      const CHAIN_RANDOM_SPLIT_PROB = 0.0015;
      const CHAIN_MAX_ANGLE = (25 * Math.PI) / 180;

      // Chains organized by color: { "#d0021b": [chain1, chain2, ...], "#4a90e2": [...], ... }
      // each chain: { dots: [ {el, pos, vel}... ], angle, velocity, lastAdd, targetAngle, color }
      let chainsByColor = {};

      // Track when each color last spawned (for coordinated duplication)
      let colorLastSpawn = {};
      let currentSpawnColorIndex = 0;

      // ================== existing non-red movement ==================

      function initCornerMovement(dot) {
        const container = dot.parentElement;
        const isLeft =
          container.classList.contains("top-left") ||
          container.classList.contains("bottom-left") ||
          container.classList.contains("left-margin");
        const isLeftMargin = container.classList.contains("left-margin");

        const data = {
          x: Math.random() * 60,
          y: isLeftMargin ? (Math.random() - 0.5) * 200 : Math.random() * 60,
          vx: (Math.random() - 0.5) * 1,
          vy: (Math.random() - 0.5) * 1,
          targetX: Math.random() * 80,
          targetY: isLeftMargin
            ? (Math.random() - 0.5) * 200
            : Math.random() * 80,
          opacity: 0.4 + Math.random() * 0.6,
          opacityDir: Math.random() > 0.5 ? 1 : -1,
          speed: 0.15 + Math.random() * 0.35,
          bounds: isLeftMargin
            ? { minX: -20, maxX: 100, minY: -100, maxY: 100 }
            : { minX: -20, maxX: 100, minY: -20, maxY: 100 },
        };
        dotMovement.set(dot, data);
        updateCornerDotPosition(dot);
      }

      function initInnerMovement(dot, startX = 0, startY = 0) {
        const maxRadius = 350;
        const data = {
          x: startX,
          y: startY,
          vx: (Math.random() - 0.5) * 1.5,
          vy: (Math.random() - 0.5) * 1.5,
          targetX: (Math.random() - 0.5) * maxRadius * 1.5,
          targetY: (Math.random() - 0.5) * maxRadius * 1.5,
          opacity: 0.5 + Math.random() * 0.5,
          opacityDir: Math.random() > 0.5 ? 1 : -1,
          speed: 0.25 + Math.random() * 0.5,
          maxRadius: maxRadius,
        };
        dotMovement.set(dot, data);
        updateInnerDotPosition(dot);
      }

      function updateCornerDotPosition(dot) {
        const data = dotMovement.get(dot);
        if (!data || dot.classList.contains("dragging")) return;

        const dx = data.targetX - data.x;
        const dy = data.targetY - data.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 5) {
          data.targetX =
            data.bounds.minX +
            Math.random() * (data.bounds.maxX - data.bounds.minX);
          data.targetY =
            data.bounds.minY +
            Math.random() * (data.bounds.maxY - data.bounds.minY);
          data.speed = 0.15 + Math.random() * 0.35;
        }

        data.vx += (dx / dist) * 0.05 * data.speed;
        data.vy += (dy / dist) * 0.05 * data.speed;

        data.vx += (Math.random() - 0.5) * 0.1;
        data.vy += (Math.random() - 0.5) * 0.1;

        data.vx *= 0.97;
        data.vy *= 0.97;

        data.x += data.vx;
        data.y += data.vy;

        if (data.x < data.bounds.minX) {
          data.x = data.bounds.minX;
          data.vx *= -0.5;
        }
        if (data.x > data.bounds.maxX) {
          data.x = data.bounds.maxX;
          data.vx *= -0.5;
        }
        if (data.y < data.bounds.minY) {
          data.y = data.bounds.minY;
          data.vy *= -0.5;
        }
        if (data.y > data.bounds.maxY) {
          data.y = data.bounds.maxY;
          data.vy *= -0.5;
        }

        data.opacity += data.opacityDir * 0.0025;
        if (data.opacity > 1) {
          data.opacity = 1;
          data.opacityDir = -1;
        }
        if (data.opacity < 0.3) {
          data.opacity = 0.3;
          data.opacityDir = 1;
        }

        dot.style.transform = `translate(${data.x}px, ${data.y}px)`;
        dot.style.opacity = data.opacity;
      }

      function updateInnerDotPosition(dot) {
        const data = dotMovement.get(dot);
        if (!data || dot.classList.contains("dragging")) return;

        const dx = data.targetX - data.x;
        const dy = data.targetY - data.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 10) {
          const angle = Math.random() * Math.PI * 2;
          const radius = Math.random() * data.maxRadius;
          data.targetX = Math.cos(angle) * radius;
          data.targetY = Math.sin(angle) * radius;
          data.speed = 0.25 + Math.random() * 0.5;
        }

        if (dist > 0) {
          data.vx += (dx / dist) * 0.075 * data.speed;
          data.vy += (dy / dist) * 0.075 * data.speed;
        }

        data.vx += (Math.random() - 0.5) * 0.15;
        data.vy += (Math.random() - 0.5) * 0.15;

        data.vx *= 0.98;
        data.vy *= 0.98;

        data.x += data.vx;
        data.y += data.vy;

        const currentDist = Math.sqrt(data.x * data.x + data.y * data.y);
        if (currentDist > data.maxRadius) {
          const scale = data.maxRadius / currentDist;
          data.x *= scale;
          data.y *= scale;
          data.vx *= -0.3;
          data.vy *= -0.3;
        }

        data.opacity += data.opacityDir * 0.004;
        if (data.opacity > 1) {
          data.opacity = 1;
          data.opacityDir = -1;
        }
        if (data.opacity < 0.4) {
          data.opacity = 0.4;
          data.opacityDir = 1;
        }

        dot.style.left = data.x + "px";
        dot.style.top = data.y + "px";
        dot.style.opacity = data.opacity;
      }

      // ================== circle helpers ==================

      function getCircleBounds() {
        const rect = circle.getBoundingClientRect();
        return {
          centerX: rect.left + rect.width / 2,
          centerY: rect.top + rect.height / 2,
          radius: rect.width / 2,
        };
      }

      function isPointInCircle(x, y) {
        const bounds = getCircleBounds();
        const dist = Math.sqrt(
          Math.pow(x - bounds.centerX, 2) + Math.pow(y - bounds.centerY, 2)
        );
        return dist <= bounds.radius - 20;
      }

      // ================== chain logic ==================

      function initChainDot(dot, startX = 0, startY = 0) {
        const dotColor = getDotColor(dot);
        if (!dotColor) return;

        const initialAngle = Math.random() * Math.PI * 2;
        const speed = 0.8 + Math.random() * 0.6;
        const node = {
          el: dot,
          pos: v(startX, startY),
          vel: v(
            Math.cos(initialAngle) * speed,
            Math.sin(initialAngle) * speed
          ),
          opacity: 0.5 + Math.random() * 0.5,
          opacityDir: Math.random() > 0.5 ? 1 : -1,
        };

        // Initialize chains array for this color if it doesn't exist
        if (!chainsByColor[dotColor]) {
          chainsByColor[dotColor] = [];
        }

        chainsByColor[dotColor].push({
          dots: [node],
          angle: initialAngle,
          velocity: speed,
          targetAngle: initialAngle,
          lastAdd: performance.now(),
          lastDirectionChange: performance.now(),
          color: dotColor,
        });
        dot.style.left = startX + "px";
        dot.style.top = startY + "px";
      }

      function createChainDotElement(x, y, color) {
        const newDot = document.createElement("div");
        newDot.className = "inner-dot";
        newDot.style.backgroundColor = color;
        newDot.style.setProperty("--i", innerDotCounter);
        innerDotsContainer.appendChild(newDot);

        newDot.style.left = x + "px";
        newDot.style.top = y + "px";

        newDot.addEventListener("mousedown", onMouseDown);
        newDot.addEventListener("touchstart", onTouchStart, { passive: false });

        innerDotCounter++;
        return newDot;
      }

      function growChain(chain) {
        const dots = chain.dots;
        if (!dots.length) return;

        if (dots.length === 1) {
          const head = dots[0].pos;
          const headVel = dots[0].vel;
          const dir = vNorm(headVel);
          const newPos = vAdd(head, vMul(dir, -CHAIN_SPACING));
          const el = createChainDotElement(newPos.x, newPos.y, chain.color);
          dots.push({
            el,
            pos: newPos,
            vel: vMul(headVel, 0.9), // slightly slower than head
            opacity: 0.5 + Math.random() * 0.5,
            opacityDir: Math.random() > 0.5 ? 1 : -1,
          });
          return;
        }

        const addToHead = Math.random() < 0.5;
        if (addToHead) {
          const head = dots[0].pos;
          const headVel = dots[0].vel;
          const dir = vNorm(headVel);
          const newPos = vAdd(head, vMul(dir, CHAIN_SPACING));
          const el = createChainDotElement(newPos.x, newPos.y, chain.color);
          dots.unshift({
            el,
            pos: newPos,
            vel: vMul(headVel, 1.1), // slightly faster than current head
            opacity: 0.5 + Math.random() * 0.5,
            opacityDir: Math.random() > 0.5 ? 1 : -1,
          });
        } else {
          const tail = dots[dots.length - 1].pos;
          const tailVel = dots[dots.length - 1].vel;
          const dir = vNorm(tailVel);
          const newPos = vAdd(tail, vMul(dir, -CHAIN_SPACING));
          const el = createChainDotElement(newPos.x, newPos.y, chain.color);
          dots.push({
            el,
            pos: newPos,
            vel: vMul(tailVel, 0.9), // slightly slower than tail
            opacity: 0.5 + Math.random() * 0.5,
            opacityDir: Math.random() > 0.5 ? 1 : -1,
          });
        }
      }

      function splitChainAt(color, chainIndex, splitAt) {
        const chains = chainsByColor[color];
        if (!chains || !chains[chainIndex]) return;

        const chain = chains[chainIndex];
        const leftDots = chain.dots.slice(0, splitAt);
        const rightDots = chain.dots.slice(splitAt);

        // Get average velocity for each split
        const leftVel = leftDots.length > 0 ? leftDots[0].vel : v(0, 0);
        const rightVel = rightDots.length > 0 ? rightDots[0].vel : v(0, 0);
        const leftAngle = Math.atan2(leftVel.y, leftVel.x);
        const rightAngle = Math.atan2(rightVel.y, rightVel.x);

        chains.splice(chainIndex, 1);

        chains.push({
          dots: leftDots,
          angle: leftAngle + (Math.random() - 0.5) * 0.5,
          velocity: vLen(leftVel),
          targetAngle: leftAngle + (Math.random() - 0.5) * 0.3,
          lastAdd: performance.now(),
          lastDirectionChange: performance.now(),
          color: chain.color,
        });
        chains.push({
          dots: rightDots,
          angle: rightAngle + (Math.random() - 0.5) * 0.5,
          velocity: vLen(rightVel),
          targetAngle: rightAngle + (Math.random() - 0.5) * 0.3,
          lastAdd: performance.now(),
          lastDirectionChange: performance.now(),
          color: chain.color,
        });
      }

      function enforceChainSplits() {
        for (const color in chainsByColor) {
          const chains = chainsByColor[color];
          for (let i = chains.length - 1; i >= 0; i--) {
            const chain = chains[i];
            if (chain.dots.length > CHAIN_MAX_LEN) {
              const splitAt = Math.floor(chain.dots.length / 2);
              splitChainAt(color, i, splitAt);
              continue;
            }

            if (
              chain.dots.length >= 4 &&
              Math.random() < CHAIN_RANDOM_SPLIT_PROB
            ) {
              const splitAt =
                1 + Math.floor(Math.random() * (chain.dots.length - 3));
              splitChainAt(color, i, splitAt);
            }
          }
        }
      }

      function clampToCircle(pos) {
        const d = vLen(pos);
        if (d > CHAIN_MAX_RADIUS) {
          const s = CHAIN_MAX_RADIUS / d;
          pos.x *= s;
          pos.y *= s;
        }
      }

      // Determine which color should spawn next (alternates between colors)
      function getActiveSpawnColor(now) {
        // Get all chain-forming colors that have chains
        const activeColors = Object.keys(chainsByColor).filter(
          (color) => chainsByColor[color] && chainsByColor[color].length > 0
        );

        if (activeColors.length === 0) return null;
        if (activeColors.length === 1) return activeColors[0];

        // Initialize last spawn time for colors that don't have it
        for (const color of activeColors) {
          if (!(color in colorLastSpawn)) {
            colorLastSpawn[color] = 0;
          }
        }

        // Find colors that are ready to spawn (haven't spawned in CHAIN_ADD_INTERVAL)
        const readyColors = activeColors.filter(
          (color) => now - colorLastSpawn[color] >= CHAIN_ADD_INTERVAL
        );

        if (readyColors.length === 0) return null;

        // If multiple colors are ready, alternate between them
        // Find the color with the oldest lastSpawn time
        let oldestColor = readyColors[0];
        let oldestTime = colorLastSpawn[oldestColor];

        for (const color of readyColors) {
          if (colorLastSpawn[color] < oldestTime) {
            oldestTime = colorLastSpawn[color];
            oldestColor = color;
          }
        }

        return oldestColor;
      }

      function updateChains() {
        const now = performance.now();

        // Determine which color should spawn this frame
        const activeSpawnColor = getActiveSpawnColor(now);

        // Track if we've spawned for each color this frame (to update colorLastSpawn once per color)
        const spawnedThisFrame = {};

        for (const color in chainsByColor) {
          const chains = chainsByColor[color];
          const isActiveColor = color === activeSpawnColor;

          for (const chain of chains) {
            const dots = chain.dots;
            if (!dots.length) continue;

            // Update head (first dot) - moves freely like a single dot
            const head = dots[0];
            const speed = chain.velocity || 1.0;
            const dist = vLen(head.pos);

            // Random direction changes for ribbon-like flow (every 1-3 seconds)
            if (now - chain.lastDirectionChange > 1000 + Math.random() * 2000) {
              // Vary direction changes more - sometimes toward center, sometimes random
              if (Math.random() < 0.3 && dist > CHAIN_MAX_RADIUS * 0.3) {
                // 30% chance to move toward center if far from center
                const toCenter = vNorm(vMul(head.pos, -1));
                chain.targetAngle =
                  Math.atan2(toCenter.y, toCenter.x) +
                  (Math.random() - 0.5) * 0.4;
              } else {
                // Otherwise random direction
                chain.targetAngle =
                  chain.angle + (Math.random() - 0.5) * Math.PI * 1.2;
              }
              chain.lastDirectionChange = now;
            }

            // Smoothly interpolate angle towards target
            let angleDiff = chain.targetAngle - chain.angle;
            // Normalize angle difference to [-PI, PI]
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            chain.angle += angleDiff * 0.02; // Smooth interpolation

            // Add some random variation for organic movement
            chain.angle += (Math.random() - 0.5) * 0.04;

            // Update velocity based on angle
            head.vel.x = Math.cos(chain.angle) * speed;
            head.vel.y = Math.sin(chain.angle) * speed;

            // Add small random perturbations for organic flow
            head.vel.x += (Math.random() - 0.5) * 0.2;
            head.vel.y += (Math.random() - 0.5) * 0.2;

            // Slight attraction toward center if far from center (weak force)
            if (dist > CHAIN_MAX_RADIUS * 0.4) {
              const centerPull = 0.02;
              const toCenter = vNorm(vMul(head.pos, -1));
              head.vel.x += toCenter.x * centerPull;
              head.vel.y += toCenter.y * centerPull;
            }

            // Apply damping
            head.vel.x *= 0.98;
            head.vel.y *= 0.98;

            // Update position
            head.pos.x += head.vel.x;
            head.pos.y += head.vel.y;

            // Keep head inside bubble with smooth boundary reflection
            const newDist = vLen(head.pos);
            if (newDist > CHAIN_MAX_RADIUS) {
              const normal = vNorm(head.pos);
              // Reflect velocity off boundary
              const dot = head.vel.x * normal.x + head.vel.y * normal.y;
              head.vel.x -= 2 * dot * normal.x;
              head.vel.y -= 2 * dot * normal.y;
              // Clamp position
              head.pos.x = normal.x * CHAIN_MAX_RADIUS;
              head.pos.y = normal.y * CHAIN_MAX_RADIUS;
              // Update angle to match new velocity
              chain.angle = Math.atan2(head.vel.y, head.vel.x);
            }

            // Update followers - each dot only attracted to 1-2 adjacent dots
            for (let i = 1; i < dots.length; i++) {
              const prev = dots[i - 1];
              const cur = dots[i];

              // Calculate direction to previous dot
              const toPrev = vSub(prev.pos, cur.pos);
              const distToPrev = vLen(toPrev);

              // Attraction force to maintain spacing
              let targetPos;
              if (distToPrev > 0) {
                const desiredDist = CHAIN_SPACING;
                const dir = vNorm(toPrev);

                // If too close, push away; if too far, pull closer
                if (distToPrev < desiredDist * 0.8) {
                  // Too close - move away
                  targetPos = vAdd(cur.pos, vMul(dir, -desiredDist * 0.3));
                } else if (distToPrev > desiredDist * 1.2) {
                  // Too far - move closer
                  targetPos = vAdd(prev.pos, vMul(dir, -desiredDist));
                } else {
                  // Good distance - follow smoothly
                  targetPos = vAdd(prev.pos, vMul(dir, -desiredDist));
                }
              } else {
                targetPos = cur.pos;
              }

              // Smooth movement towards target
              const lerpFactor = 0.15;
              cur.pos.x = vLerp(cur.pos, targetPos, lerpFactor).x;
              cur.pos.y = vLerp(cur.pos, targetPos, lerpFactor).y;

              // Update velocity for smoothness
              const velToTarget = vSub(targetPos, cur.pos);
              cur.vel = vLerp(cur.vel, vMul(velToTarget, 0.1), 0.3);

              // Keep inside bubble
              const curDist = vLen(cur.pos);
              if (curDist > CHAIN_MAX_RADIUS) {
                const normal = vNorm(cur.pos);
                cur.pos.x = normal.x * CHAIN_MAX_RADIUS;
                cur.pos.y = normal.y * CHAIN_MAX_RADIUS;
                // Reflect velocity
                const dot = cur.vel.x * normal.x + cur.vel.y * normal.y;
                cur.vel.x -= 2 * dot * normal.x;
                cur.vel.y -= 2 * dot * normal.y;
              }
            }

            // Update opacity for each node
            for (const node of dots) {
              // Initialize opacity if not set
              if (node.opacity === undefined) {
                node.opacity = 0.5 + Math.random() * 0.5;
                node.opacityDir = Math.random() > 0.5 ? 1 : -1;
              }

              // Animate opacity (similar to regular dots)
              node.opacity += node.opacityDir * 0.004;
              if (node.opacity > 1) {
                node.opacity = 1;
                node.opacityDir = -1;
              }
              if (node.opacity < 0.4) {
                node.opacity = 0.4;
                node.opacityDir = 1;
              }
            }

            // Write to DOM
            for (const node of dots) {
              node.el.style.left = node.pos.x + "px";
              node.el.style.top = node.pos.y + "px";
              node.el.style.opacity = node.opacity;
            }

            // Growth - only for the active spawn color
            if (
              isActiveColor &&
              now - chain.lastAdd > CHAIN_ADD_INTERVAL &&
              now - (colorLastSpawn[color] || 0) >= CHAIN_ADD_INTERVAL
            ) {
              chain.lastAdd = now;
              colorLastSpawn[color] = now; // Update color-level spawn time
              growChain(chain);
            }
          }
        }

        enforceChainSplits();
      }

      function updateChainDotPositionFromDrag(dot, newX, newY) {
        for (const color in chainsByColor) {
          const chains = chainsByColor[color];
          for (const chain of chains) {
            for (const node of chain.dots) {
              if (node.el === dot) {
                node.pos.x = newX;
                node.pos.y = newY;
                // Reset velocity after drag
                if (node.vel) {
                  node.vel.x = 0;
                  node.vel.y = 0;
                }
                return;
              }
            }
          }
        }
      }

      // ================== inner dot creation / duplication ==================

      function moveToInnerCircle(dot, dropX, dropY) {
        const color = window.getComputedStyle(dot).backgroundColor;
        const bounds = getCircleBounds();

        const relX = dropX - bounds.centerX;
        const relY = dropY - bounds.centerY;

        dot.remove();
        dotMovement.delete(dot);
        createInnerDot(color, relX, relY);
      }

      function createInnerDot(color, offsetX = 0, offsetY = 0) {
        const newDot = document.createElement("div");
        newDot.className = "inner-dot";

        const finalColor = color || colors[innerDotCounter % colors.length];
        newDot.style.backgroundColor = finalColor;
        newDot.style.setProperty("--i", innerDotCounter);

        innerDotsContainer.appendChild(newDot);

        if (isChainFormingColorString(finalColor)) {
          initChainDot(newDot, offsetX, offsetY);
        } else {
          initInnerMovement(newDot, offsetX, offsetY);
        }

        newDot.addEventListener("mousedown", onMouseDown);
        newDot.addEventListener("touchstart", onTouchStart, { passive: false });

        innerDotCounter++;
        return newDot;
      }

      function duplicateInnerDot(original) {
        const color = window.getComputedStyle(original).backgroundColor;
        const data = dotMovement.get(original);

        if (data) {
          const randomAngle = Math.random() * Math.PI * 2;
          const randomDist = 20 + Math.random() * 30;
          const spawnX = data.x + Math.cos(randomAngle) * randomDist;
          const spawnY = data.y + Math.sin(randomAngle) * randomDist;
          createInnerDot(color, spawnX, spawnY);
        } else {
          createInnerDot(color, 0, 0);
        }
      }

      // ================== dragging ==================

      function onMouseDown(e) {
        e.preventDefault();
        e.stopPropagation();
        activeDot = e.target;
        activeDot.classList.add("dragging");

        const rect = activeDot.getBoundingClientRect();
        const offsetX = e.clientX - rect.left;
        const offsetY = e.clientY - rect.top;

        startX = e.clientX;
        startY = e.clientY;
        dotStartX = rect.left;
        dotStartY = rect.top;

        activeDot.dataset.offsetX = offsetX;
        activeDot.dataset.offsetY = offsetY;

        activeDot.style.position = "fixed";
        activeDot.style.left = dotStartX + "px";
        activeDot.style.top = dotStartY + "px";
        activeDot.style.transform = "scale(1.3)";
      }

      function onTouchStart(e) {
        e.preventDefault();
        e.stopPropagation();
        activeDot = e.target;
        activeDot.classList.add("dragging");

        const rect = activeDot.getBoundingClientRect();
        const offsetX = e.touches[0].clientX - rect.left;
        const offsetY = e.touches[0].clientY - rect.top;

        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        dotStartX = rect.left;
        dotStartY = rect.top;

        activeDot.dataset.offsetX = offsetX;
        activeDot.dataset.offsetY = offsetY;

        activeDot.style.position = "fixed";
        activeDot.style.left = dotStartX + "px";
        activeDot.style.top = dotStartY + "px";
        activeDot.style.transform = "scale(1.3)";
      }

      function onMouseMove(e) {
        if (!activeDot) return;
        e.preventDefault();

        const offsetX = parseFloat(activeDot.dataset.offsetX) || 0;
        const offsetY = parseFloat(activeDot.dataset.offsetY) || 0;

        activeDot.style.left = e.clientX - offsetX + "px";
        activeDot.style.top = e.clientY - offsetY + "px";
      }

      function onTouchMove(e) {
        if (!activeDot) return;
        e.preventDefault();

        const offsetX = parseFloat(activeDot.dataset.offsetX) || 0;
        const offsetY = parseFloat(activeDot.dataset.offsetY) || 0;

        activeDot.style.left = e.touches[0].clientX - offsetX + "px";
        activeDot.style.top = e.touches[0].clientY - offsetY + "px";
      }

      function onEnd(e) {
        if (!activeDot) return;

        const rect = activeDot.getBoundingClientRect();
        const dotX = rect.left + rect.width / 2;
        const dotY = rect.top + rect.height / 2;
        const wasInnerDot = activeDot.classList.contains("inner-dot");
        const droppedInCircle = isPointInCircle(dotX, dotY);

        activeDot.classList.remove("dragging");

        if (droppedInCircle && !wasInnerDot) {
          moveToInnerCircle(activeDot, dotX, dotY);
        } else if (wasInnerDot) {
          const bounds = getCircleBounds();
          const newX = dotX - bounds.centerX;
          const newY = dotY - bounds.centerY;

          activeDot.style.position = "";
          activeDot.style.transform = "";

          if (isChainFormingDot(activeDot)) {
            updateChainDotPositionFromDrag(activeDot, newX, newY);
          } else {
            const data = dotMovement.get(activeDot);
            if (data) {
              data.x = newX;
              data.y = newY;
              data.vx = 0;
              data.vy = 0;
            }
            updateInnerDotPosition(activeDot);
          }
        } else {
          activeDot.style.position = "";
          activeDot.style.transform = "";

          const container = activeDot.parentElement;
          const containerRect = container.getBoundingClientRect();
          const data = dotMovement.get(activeDot);
          if (data) {
            data.x = dotX - containerRect.left - 12;
            data.y = dotY - containerRect.top - 12;
            data.vx = 0;
            data.vy = 0;
          }
        }

        activeDot = null;
      }

      // ================== animation loop ==================

      function animate() {
        document
          .querySelectorAll(".corner-dot")
          .forEach(updateCornerDotPosition);

        document.querySelectorAll(".inner-dot").forEach((dot) => {
          if (!isChainFormingDot(dot)) updateInnerDotPosition(dot);
        });

        updateChains();
        updateTrackVolumes(); // Update track volumes based on dots in bubble

        requestAnimationFrame(animate);
      }

      // ================== audio player ==================

      const playButton = document.getElementById("play-button");

      // Create audio elements for all tracks
      const audioPlayers = [];
      const trackCount = 7; // 1track.mp3 through 7track.mp3

      for (let i = 1; i <= trackCount; i++) {
        const audio = new Audio(`assets/music/${i}track.mp3`);
        audioPlayers.push(audio);
      }

      // Color-to-track mapping: maps dot colors to track indices (2-7)
      // Track 1 (index 0) is always unmuted
      const COLOR_TO_TRACK_MAP = {
        "#4a90e2": 1, // blue (top-left) -> 2track.mp3
        "#f57023": 2, // orange (top-right) -> 3track.mp3
        "#7ed321": 3, // green (bottom-left) -> 4track.mp3
        "#d0021b": 4, // red (bottom-right) -> 5track.mp3
        "#9b59b6": 5, // purple (left-margin) -> 6track.mp3
        "#ffae00": 6, // yellow/orange (right-margin) -> 7track.mp3
      };

      let isPlaying = false;

      // Function to play all tracks
      function playAllTracks() {
        // Set initial volumes: track 1 unmuted, tracks 2-7 muted
        audioPlayers[0].volume = 1.0; // Track 1 always unmuted
        for (let i = 1; i < audioPlayers.length; i++) {
          audioPlayers[i].volume = 0.0; // Tracks 2-7 start muted
        }

        audioPlayers.forEach((audio) => {
          audio.play().catch((error) => {
            console.error("Error playing audio:", error);
          });
        });
        isPlaying = true;
        playButton.innerHTML = "⏸";
      }

      // Function to pause all tracks
      function pauseAllTracks() {
        audioPlayers.forEach((audio) => {
          audio.pause();
        });
        isPlaying = false;
        playButton.innerHTML = "▶";
      }

      // Play button click handler
      playButton.addEventListener("click", function () {
        if (isPlaying) {
          pauseAllTracks();
        } else {
          playAllTracks();
          // Hide the play button after clicking
          playButton.style.display = "none";
        }
      });

      // Reset button when all tracks end
      let endedCount = 0;
      audioPlayers.forEach((audio) => {
        audio.addEventListener("ended", function () {
          endedCount++;
          if (endedCount === audioPlayers.length) {
            isPlaying = false;
            playButton.innerHTML = "▶";
            endedCount = 0; // Reset counter
          }
        });
      });

      // ================== track volume control by dot color ==================

      // Check which dot colors are currently inside the bubble
      function checkDotsInBubble() {
        const activeColors = new Set();
        const innerDots = document.querySelectorAll(".inner-dot");

        innerDots.forEach((dot) => {
          const rect = dot.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;

          if (isPointInCircle(centerX, centerY)) {
            const color = getDotColor(dot);
            if (color && COLOR_TO_TRACK_MAP.hasOwnProperty(color)) {
              activeColors.add(color);
            }
          }
        });

        return activeColors;
      }

      // Update track volumes based on which dot colors are in the bubble
      function updateTrackVolumes() {
        if (!isPlaying) return;

        const activeColors = checkDotsInBubble();

        // Update tracks 2-7 based on active colors
        for (const [color, trackIndex] of Object.entries(COLOR_TO_TRACK_MAP)) {
          const audio = audioPlayers[trackIndex];
          audio.volume = activeColors.has(color) ? 1.0 : 0.0;
        }
      }

      // ================== preload background ==================

      function preloadBackground() {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => resolve();
          img.onerror = () => resolve(); // Continue even if image fails
          img.src = "assets/noisy_bckg.png";
        });
      }

      // ================== init ==================

      document.addEventListener("DOMContentLoaded", function () {
        // Preload background, then show content
        preloadBackground().then(() => {
          document.body.classList.add("loaded");
        });

        const dots = document.querySelectorAll(".corner-dot");

        dots.forEach((dot) => {
          initCornerMovement(dot);
          dot.addEventListener("mousedown", onMouseDown);
          dot.addEventListener("touchstart", onTouchStart, { passive: false });
        });

        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onEnd);
        document.addEventListener("touchmove", onTouchMove, { passive: false });
        document.addEventListener("touchend", onEnd);

        animate();

        const MAX_INNER_DOTS = 150;
        let lastSpawnColor = null;

        setInterval(() => {
          const bounds = getCircleBounds();
          const allInnerDots = document.querySelectorAll(".inner-dot");
          const currentCount = allInnerDots.length;

          const innerDots = Array.from(
            document.querySelectorAll(".inner-dot:not(.dragging)")
          ).filter((dot) => {
            if (isChainFormingDot(dot)) return false; // do not include chain-forming dots in this duplication

            const rect = dot.getBoundingClientRect();
            const dotCenterX = rect.left + rect.width / 2;
            const dotCenterY = rect.top + rect.height / 2;

            const dist = Math.sqrt(
              Math.pow(dotCenterX - bounds.centerX, 2) +
                Math.pow(dotCenterY - bounds.centerY, 2)
            );

            if (!dotMovement.has(dot)) {
              const relX = dotCenterX - bounds.centerX;
              const relY = dotCenterY - bounds.centerY;
              initInnerMovement(dot, relX, relY);
            }

            return dist < bounds.radius - 30;
          });

          if (innerDots.length > 0 && currentCount < MAX_INNER_DOTS) {
            const dotsByColor = {};
            innerDots.forEach((dot) => {
              const color = window.getComputedStyle(dot).backgroundColor;
              if (!dotsByColor[color]) {
                dotsByColor[color] = [];
              }
              dotsByColor[color].push(dot);
            });

            const allColors = Object.keys(dotsByColor);
            const availableColors = allColors.filter(
              (c) => c !== lastSpawnColor
            );

            const colorsToChooseFrom =
              availableColors.length > 0 ? availableColors : allColors;

            if (colorsToChooseFrom.length > 0) {
              const chosenColor =
                colorsToChooseFrom[
                  Math.floor(Math.random() * colorsToChooseFrom.length)
                ];

              const dotsOfColor = dotsByColor[chosenColor];
              const parentDot =
                dotsOfColor[Math.floor(Math.random() * dotsOfColor.length)];

              duplicateInnerDot(parentDot);
              lastSpawnColor = chosenColor;
            }
          }
        }, 2000);
      });
    </script>
  </body>
</html>
